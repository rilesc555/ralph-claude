# Ralph Progress Log
Effort: remote-loop-execution
Type: Bug Investigation (Feasibility Study)
Started: 2026-01-23
Rotation: 1 (rotated at 2026-01-23 13:54)

## Codebase Patterns
- DUAL-MODE agent management: tmux for claude, opencode serve for opencode
- Claude: Sessions run in detached tmux sessions via libtmux (session.py)
- Claude: Tmux sessions use `remain-on-exit`, `tmux_session_alive()` checks `pane_dead_status`
- Claude: Attach is `tmux attach-session -t <name>`, stop uses signal files
- OpenCode: `opencode serve --port <auto>` starts headless HTTP server
- OpenCode: TUI via `opencode attach http://localhost:<port>` — native opencode experience
- OpenCode: Prompts sent via `POST /session/:id/message` (sync) or `prompt_async` (async)
- OpenCode: Completion detected via SSE events (`GET /event`) — `session.idle` event
- OpenCode: Stop via `POST /session/:id/abort`, health via `GET /global/health`
- OpenCode: Server stores sessions in `~/.opencode/data/storage/` (filesystem, not SQLite)
- OpenCode: Multiple clients can connect simultaneously (SSE broadcast)
- OpenCode: `OPENCODE_SERVER_PASSWORD` enables HTTP Basic Auth
- OpenCode server mode: OpencodeServer class in opencode_server.py manages lifecycle
- OpenCode server mode: Port range 14096-14196 for auto-assignment
- OpenCode server mode: Loop sends sync prompts (POST /session/:id/message blocks until done)
- OpenCode server mode: Process group created with os.setsid for clean shutdown
- Session state tracked in SQLite at `~/.local/share/ralph/sessions.db`
- Sessions table has session_type (tmux|opencode-server) and server_port columns
- CLI routes agent=opencode to opencode-server mode, agent=claude to tmux mode
- CLI uses Click, session management uses libtmux (not subprocess tmux calls)
- Progress file rotation preserves Codebase Patterns section across rotations
- For remote opencode: Ziti proxies the HTTP port, `opencode attach http://<ziti>:<port>` works
- For remote claude: proxy tmux socket over Ziti or SSH-over-Ziti tunnel
- OpenZiti Python SDK (v1.5.0): no native asyncio, but Ziti fds are epoll-compatible on Linux
- SDK supports multiple service binds per process from one ZitiContext
- Identity loaded via openziti.load(path) returning ZitiContext; one context can host N services
- Remote opencode attach: Ziti tunneler proxies HTTP port → `opencode attach http://<intercept>:<port>` (zero app changes)
- Remote claude attach: SSH-over-Ziti with ProxyCommand (tmux socket proxy NOT feasible)
- OpenCode's client-side rendering means keystroke latency is LOCAL for remote sessions (only prompt submission is an RTT)
- SSE over Ziti: works perfectly, chunked HTTP needs no special handling, events flush immediately
- Stop/checkpoint for remote: use daemon control RPC (transport-agnostic), not transport-specific mechanisms


## Prior Progress
Completed 0 iterations in progress-1.txt.
_See progress-1.txt for detailed iteration logs._

---

---
CHECKPOINT at 2026-01-23 14:06
Iteration: 7/20 | Stories: 3/7 | Agent: opencode
Reason: shutdown signal
---

---
CHECKPOINT at 2026-01-23 14:58
Iteration: 10/20 | Stories: 3/8 | Agent: opencode
Reason: shutdown signal
---

---
CHECKPOINT at 2026-01-23 15:21
Iteration: 5/20 | Stories: 3/8 | Agent: opencode
Reason: shutdown signal
---

---
CHECKPOINT at 2026-01-23 16:04
Iteration: 3/20 | Stories: 3/8 | Agent: opencode
Reason: shutdown signal
---

---
CHECKPOINT at 2026-01-23 16:06
Iteration: 1/20 | Stories: 3/8 | Agent: opencode
Reason: shutdown signal
---

## 2026-01-23 16:30 - US-004
- Implemented opencode server mode for local loops
- Created new module: `src/ralph_uv/opencode_server.py` (~480 lines)
  - `OpencodeServer` class: manages `opencode serve` subprocess lifecycle
  - Port auto-assignment (range 14096-14196), health checking, HTTP API client
  - `create_session()`, `send_prompt()`, `wait_for_idle()` (SSE), `abort_session()`
  - Proper process group management (SIGTERM → SIGKILL with timeout)
- Modified `src/ralph_uv/cli.py`:
  - When agent=opencode, routes to `_spawn_opencode_server()` instead of tmux
  - Starts server, waits for health, registers in SQLite, runs loop in-process
- Modified `src/ralph_uv/loop.py`:
  - `LoopRunner` accepts `opencode_server` parameter
  - `_run_agent_via_server()`: creates sessions and sends sync prompts via HTTP
- Modified `src/ralph_uv/attach.py`:
  - Dispatches to `opencode attach http://localhost:<port>` for opencode-server sessions
  - Falls back to tmux attach for tmux sessions
- Modified `src/ralph_uv/session.py`:
  - Added `session_type` and `server_port` columns with migration support
  - `opencode_server_alive()` health check function
  - `stop_session()` kills server process for opencode-server sessions
  - `cleanup_session()` handles both session types
  - `list_running()` and `get_status()` validate per session type
- **Learnings for future iterations:**
  - `opencode serve --port 0` lets OS assign a port, but the assigned port isn't printed to stdout — we find free ports ourselves
  - `POST /session/:id/message` is synchronous (blocks until agent responds) — perfect for loop iteration model
  - The `opencode attach <url>` command provides the native TUI over HTTP — no terminal proxying needed
  - `preexec_fn=os.setsid` creates a process group, allowing clean SIGTERM to all children
  - SQLite schema migration uses PRAGMA table_info to detect missing columns
   - mypy strict mode requires explicit bool() for comparison expressions in returns
---

## 2026-01-23 17:00 - US-005
- Assessed remote attach/monitoring feasibility over OpenZiti for both agent types
- Created: `tasks/remote-loop-execution/remote-attach-assessment.md` (comprehensive analysis)
- Updated: `tasks/remote-loop-execution/prd.json` (notes with findings summary)
- Key findings:
  - OpenCode remote attach is trivial: HTTP proxy over Ziti, zero app changes, ~20 lines
  - Claude remote attach via SSH-over-Ziti: native tmux experience, ~30 lines
  - Tmux socket proxy is NOT feasible (shared memory, SO_PEERCRED, ioctls)
  - Latency: OpenCode is latency-insensitive (client-side rendering, typing is local)
  - Latency: Claude/tmux is acceptable for observation (ralph-uv primary use case)
  - SSE over Ziti works perfectly (chunked HTTP, flushed immediately, no buffering)
  - Same-LAN: both agents feel local (<26ms added by Ziti)
  - Cross-region: opencode excellent, claude acceptable
- **Learnings for future iterations:**
  - opencode attach is already an HTTP client — any reachable URL works, no modifications needed
  - Tmux socket protocol uses shared memory and SO_PEERCRED — cannot be naively proxied over network
  - SSH ProxyCommand pattern enables SSH-over-any-transport with zero code changes
  - SSE (chunked HTTP) needs no special handling over TCP proxies like Ziti tunnelers
  - OpenCode's client-side rendering means keystroke latency is LOCAL even for remote sessions
  - Stop/checkpoint should use daemon RPC (transport-agnostic), not transport-specific mechanisms
---
